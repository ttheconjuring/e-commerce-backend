package com.demo.service.impl;

import com.demo.common.command.Command;
import com.demo.common.command.order.CancelOrderCommand;
import com.demo.common.command.order.CompleteOrderCommand;
import com.demo.common.command.payment.ProcessPaymentCommand;
import com.demo.common.command.product.ConfirmAvailabilityCommand;
import com.demo.common.command.product.UpdateProductsCommand;
import com.demo.common.constant.Topics;
import com.demo.model.OutboxCommand;
import com.demo.model.Status;
import com.demo.repository.OutboxCommandRepository;
import com.demo.service.OutboxCommandService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Concrete implementation of the {@link OutboxCommandService} interface.
 * <p>
 * This service is a core component of the Transactional Outbox pattern.
 * Its primary responsibility is to take a generic {@link Command} object
 * (generated by an event handler) and persist it as an {@link OutboxCommand}
 * entity in the database.
 * <p>
 * This operation is designed to be called *within* the same database
 * transaction as the saga's state update (e.g., in {@link OrderStateServiceImpl}),
 * ensuring that a command is only saved if the state change is also successful.
 *
 * @see com.demo.repository.OutboxCommandRepository
 * @see com.demo.component.OutboxPoller
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class OutboxCommandServiceImpl implements OutboxCommandService {

    private final OutboxCommandRepository outboxCommandRepository;

    /**
     * {@inheritDoc}
     * <p>
     * This implementation builds a new {@link OutboxCommand} entity from the
     * provided {@link Command}.
     * <p>
     * Its most important responsibility is **topic routing**. It inspects the
     * concrete type of the command (e.g., {@code ProcessPaymentCommand}) using
     * {@code instanceof} and sets the correct destination {@code topic}
     * (e.g., {@link Topics#PAYMENT_COMMANDS_TOPIC}).
     * <p>
     * It sets the initial status to {@link Status#PENDING_PUBLISHING},
     * so that the {@link com.demo.component.OutboxPoller} can pick it up.
     * This method is {@link @Transactional} and flushes the save immediately.
     */
    @Transactional
    @Override
    public void create(Command command) {
        OutboxCommand outboxCommand = new OutboxCommand();

        // 1. Copy common command properties
        outboxCommand.setId(command.getId());
        outboxCommand.setName(command.getName());
        outboxCommand.setCorrelationId(command.getCorrelationId());
        outboxCommand.setCommand(command); // The full JSON payload
        outboxCommand.setTimestamp(command.getTimestamp());
        outboxCommand.setStatus(Status.PENDING_PUBLISHING);

        // 2. Perform Topic Routing based on command type
        if (command instanceof CancelOrderCommand ||
                command instanceof CompleteOrderCommand) {
            outboxCommand.setTopic(Topics.ORDER_COMMANDS_TOPIC);
        } else if (command instanceof ProcessPaymentCommand) {
            outboxCommand.setTopic(Topics.PAYMENT_COMMANDS_TOPIC);
        } else if (command instanceof ConfirmAvailabilityCommand ||
                command instanceof UpdateProductsCommand) {
            outboxCommand.setTopic(Topics.PRODUCT_COMMANDS_TOPIC);
        } else {
            outboxCommand.setTopic(Topics.SHIPMENT_COMMANDS_TOPIC);
        }

        // 3. Save to database atomically
        this.outboxCommandRepository.saveAndFlush(outboxCommand);
    }


    /**
     * {@inheritDoc}
     * <p>
     * This is a scheduled housekeeping task that runs periodically (every 2 minutes)
     * to clean up the outbox table.
     * <p>
     * It finds all commands that have been successfully
     * marked as {@link Status#PUBLISHED} and deletes them in a
     * single bulk operation to prevent the table from growing indefinitely.
     */
    @Transactional
    @Scheduled(fixedRate = 120000) // 2 min
    // @Scheduled(cron = "0 0 3 * * 0") // 03:00 Every Sunday
    @Override
    public void deletePublished() {
        this.outboxCommandRepository.deleteAll(this.outboxCommandRepository.findByStatus(Status.PUBLISHED));
    }

    /**
     * {@inheritDoc}
     * <p>
     * This method is called by the {@link com.demo.component.OutboxPoller}
     * to update the status of a command after a publishing attempt.
     * It is {@link @Transactional} to ensure the status update is
     * committed immediately.
     *
     * @param outboxCommand The *managed* entity to update.
     * @param newStatus     The new status (e.g., {@link Status#PUBLISHED} or
     * {@link Status#PUBLISHING_FAILED}).
     */
    @Transactional
    @Override
    public void update(OutboxCommand outboxCommand, Status newStatus) {
        outboxCommand.setStatus(newStatus);
        this.outboxCommandRepository.saveAndFlush(outboxCommand);
    }
}
